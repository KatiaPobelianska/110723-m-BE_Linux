Тема занятия: Исправление ошибок. Работа с ветками. Настройка .gidignore

-- Working Directory --
(это без git add . + git commit -m)

1. Откатить на один шаг назад, если не было! git add . + git commit -m

эта команда уничтожит всё полезное безвозвратно
git checkout [name.file]
git checkout .

2. Эта команда позволяет удалить all files !Unrtacked

git clean -xdn / -xdf

--ключи команды: 

-х -> позвол. уд даже файлы, добавленные в гид игнор, т.е. она отменить те правила, кот испол. гид

-d -> уд. директории со всем их содержимым 
 
-f -> force - без этого ключа команда git client не работает, она просто ничего не делает

-n -> покажет список файлов, которые будут удалены перед удалением!


-- если не надо уд все файлы, то git clean [name.file], [name.file]

-------ещё можно использовать rm [названиеФайла.txt]

 ----------------

-- Stage Directory --

c git add . -> это когда уже файлы находятся в stageArea

1. Изъять файл из Stage Directory git restore --staged [name.file]

git reset [name.file] -> old school


2. В случае неверного коммита 

2.1 
эта команда переписывает последний коммит, изменяя даже его шрилан-код. При помощи этой команды мы можем тагже добавить какие-либо файлы, которых нам не хватало в коммите
git commit --amend -m "Bad last commit"

2.2
 git reset HEAD^^ -> эта команда с каретами помогает нам переместится туда, где нет ошибки, карета = 1 шаг назад

git reset HEAD~1 => на 1 коммит, будет 2 => то на 2

2.3
 !!!! ДО PUSH - изменить историю НЕпоследнего коммита
стр 260 команда git rebase

--------------

-- Плохой commit уже отправлен на сервер --

-- ПРАВИЛЬНЫЙ СПОСОБ (ПОДРАЗУМЕВАЕСЯ РАБОТА В КОМАНДЕ!)

1. git revert -> эта команда ничего НЕ УДАЛЯЕТ = это важно! она не портит историю, она создает new commit, но этот commit будет польностью зеркален предыдущему commit, т.е. по сути git revert отменяет действия моего последнего commit и уже после revert я могу написать уже какой-то хороший commit
---- Далее откр VI редактор (начать писать большая I, выйти без сохранения => ESC :q!, :wq => это выход с сохранением)

-------------
2. тот случай, когда работаешь один
--- Костыльный способ:
git reset HEAD~3
-------------


git commit -a -m => -a - это ключ, кот. заменяет команду git add . и !все файлы Modified добавятся в index, т.е. по сути можно т.о. пропустить команду add

git push --force => команда для переписания истории коммитов на сервере GitHub принудительно(подогнать ее под историю, кот у вас есть локально)!!!(локальная история - она правильная)

-------------

--- Удаление ОТДЕЛЬНО ----

--Как быстро восстановить при помощи git restore <file.name>
1. echo "same text" >> file1.txt
	+ git status
	  git add
	  git commit -m "add file1"	
	  git push 
1.1
 rm file1.txt
	git status => deleted
*если файл уже был хотя бы один раз был зафиксирован в гид, то команда:
	git restore <file.name> => поможет восстановить этот файл

2. если файл нужно удалить:
git rm <file.name>

------------

--- Как выглядела история ВЧЕРА! Перемещение по истории коммитов---

1. git checkout <5-6Ofcommit.number>

1.1 
cat file1.txt

2. git checkout main => вернуться на ветку main

----------

--- Настройка гита, что наз. git ignore file)

1. например, 2 файла: file.log 
		    + error.log => они в статусе UNtracked и вы не хотите, чтоб эти файлы попадали в коммит и гид навязчиво о этом вам напоминал.
Надо сделать так, чтоб гид их не видел:
nano .(точка, т.к. этот редактор он скрытый)gitignore => в него можно прописать те файлы, кот. вы хотите скрыть

--------------

--- Работа с ветками Branches ---

1. Разработка новой фичи, не трогая ветку main
 надо создать сначала новую ветку:
	способ_1:
	
	git branch feature1
	git branch -v => этой ком можно посмотреть на ветки, кот существуют

1.2 
переключ на новую ветку:
	git checkout feature1
	
* git checkout -b test => создать и сразу же переключиться на эту ветку

1.3 
git branch -d <branch.name> => удаление ветки
 * принудительное удаление ветки git branch -D <branch.name>

2. Слияние веток: нужно переключ на ту ветку, в кот будут вливать
	git merge <branche.name>


-----------

5.В чем отличение между fast-forward merge  and non fast-forfard merge?
Отличие между fast-forward merge и non-fast-forward merge:

Fast-Forward Merge (Быстрое объединение): Fast-forward merge происходит, когда вы пытаетесь объединить ветку в другую, и Git может сделать это просто перемещением указателя ветки вперед (вперед) без создания нового коммита слияния. Это происходит, когда ветка, в которую вы сливаете, находится впереди текущей ветки.

Non-Fast-Forward Merge (Не быстрое объединение): Non-fast-forward merge происходит, когда Git создает новый коммит слияния для объединения двух веток. Это происходит, когда вы сливаете ветку, которая разошлась от текущей ветки и имеет собственные изменения. Этот новый коммит слияния объединяет изменения из обеих веток.

6.Когда может возникнуть конфликт слияния веток, как  его разрешить?
Конфликт слияния веток может возникнуть, когда Git не может автоматически объединить изменения из двух веток. Это происходит, когда один и тот же файл в одной и той же области был изменен в обеих ветках, которые вы пытаетесь объединить. Для разрешения конфликта слияния вы можете сделать следующее:

Ручное разрешение конфликта: Вы должны открыть конфликтующий файл в текстовом редакторе и вручную выбрать, какие изменения оставить и какие отклонить. В файле будут помечены области конфликта, и вы должны удалить метки конфликта и оставить только нужные изменения.

Использование инструментов слияния: Некоторые интегрированные среды разработки (IDE) и графические клиенты для Git предоставляют инструменты для более удобного разрешения конфликтов. Вы можете использовать эти инструменты, чтобы визуально выбрать изменения.

Сохранение изменений: После разрешения конфликта вы должны сохранить файлы и добавить их в индекс с помощью команды git add. Затем завершите слияние с помощью команды git commit, и Git создаст новый коммит слияния с разрешенными изменениями.

Когда конфликт слияния разрешен и коммит слияния создан, вы можете продолжить работу с объединенными ветками.
===============
git config --global -l => -l listening => посм., что прописалось

git config --global core.editor <путь, где лежит nano> => чтобы изменить default settings и вместо VI редактора будет Nano
==============
==============
git log --oneline => список коммитов в строчном формате

git log --oneline --graph --decorate --all
===============
===============
gitk & (git key) - команда, кот в графическом режиме может показывать историю коммитов
===============
